// Code your design here
// MIPS Processor Verilog Code

module pc(lastpc,nextpc,jump,clk)
    input lastpc,jump,clk; // wire 1 bit
    output nextpc;
    wire [31:0] lastpc;
    reg [31:0] nextpc;
    wire [31:0] jump_inst;
    always@(posedge clk)
      begin
        if(jump) nextpc<=jump_inst;
    	else nextpc<=lastpc+4;
      end
endmodule
    
module instruction_mem(
  input wire [31:0] read_add,
  input wire clk,
  output reg [31:0] instruction ) // 4kb instruction memory
  reg [31:0] mem [0:1023] // to store the instructions 1024 words of a 32-bit instruction

   always @(posedge clk)
     begin
       instruction<=mem[read_add>>2]; 
     end

endmodule


module control_unit(
  input wire[4:0] op_code,
  input clk,
  output reg [6:0] instruction) // control unit with 5 instructions add,Lw,Sw,sub,branch
  
  always @(posedge clk) begin
        case (op_code)
            5'b00000: // ADD Instruction
                control_signals <= 7'b1000000; // RegWrite=1, ALUOp=00 (ADD), others=0
            5'b00001: // SUB Instruction
                control_signals <= 7'b1000010; // RegWrite=1, ALUOp=10 (SUB), others=0
            5'b00010: // LW Instruction
                control_signals <= 7'b1101000; // RegWrite=1, MemRead=1, ALUSrc=1
            5'b00011: // SW Instruction
                control_signals <= 7'b0011000; // MemWrite=1, ALUSrc=1
            5'b00100: // BRANCH Instruction
                control_signals <= 7'b0000100; // Branch=1
            default: // Default case for unsupported opcodes
                control_signals <= 7'b0000000; // No operation
        endcase
    end

endmodule
  

module register_file(
    input wire clk,                    // Clock signal
    input wire reg_write,              // Write enable signal
    input wire [4:0] read_reg1,        // Address of the first register to read
    input wire [4:0] read_reg2,        // Address of the second register to read
    input wire [4:0] write_reg,        // Address of the register to write
    input wire [31:0] write_data,      // Data to write into the register
    output reg [31:0] read_data1,      // Data read from the first register
    output reg [31:0] read_data2       // Data read from the second register
);

    // Define a 32x32 register array (32 registers, each 32 bits wide)
    reg [31:0] registers [31:0];

   
    integer i;
    initial begin
        for (i = 0; i < 32; i = i + 1) begin
            registers[i] = 0;
        end
    end

    // Read operations (combinational logic)
    always @(*) begin
        read_data1 = registers[read_reg1];
        read_data2 = registers[read_reg2];
    end

   
    always @(posedge clk) begin
        if (reg_write && write_reg != 0) begin
            registers[write_reg] <= write_data;
        end
    end

endmodule


module sign_extend(
  input wire[15:0] notextended,
  input wire clk,
  output reg[31:0] extended);
  
  always @(posedge clk)
    begin
      extended <= { {16{notextended[15]}}, notextended }; // sign extend
    end
endmodule



endmodule
  

module register_file()
